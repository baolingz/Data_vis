<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <title>JS Bin</title>
  <link rel="stylesheet" href="http://libs.cartocdn.com/cartodb.js/v3/3.15/themes/css/cartodb.css" /> 
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/leaflet.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.1/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/4.2.3/d3.min.js"></script>
  <script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
  <script src="https://cartodb-libs.global.ssl.fastly.net/carto.js/v4.0.1/carto.min.js"></script>
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.css" />
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet.draw/1.0.2/leaflet.draw.js"></script>
  <script src="https://fb.me/react-with-addons-15.1.0.js"></script>
  <script src="https://fb.me/react-dom-15.1.0.js"></script>
  
  <script src="https://cdn.jsdelivr.net/npm/vega@3"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-lite@2"></script>
  <script src="https://cdn.jsdelivr.net/npm/vega-embed@3"></script>
  <script src="http://libs.cartocdn.com/cartodb.js/v3/3.15/cartodb.js"></script>
  
  <style>
    #ui {
  width: 500px;
  height: 200px;
}

#canvas {
  width: 1200px;
  height: 650px;
  float:left;
  display: inline;
}

#chart {
  width: 1000px;
  height:100px;
  x: 000;
  y: 1000;
  
  float: left;
  display: inline-block;
}

#map {
  width: 650px;
  height: 650px;
  left: 500px;
  top: -300px;
  float: left;
  display: inline-block;
}

.legendbox {
  background: rgba(255,255,255,0.7);
  box-shadow: 0 0 15px rgba(0,0,0,0.2);
  border-radius: 5px;
  height: 45px;
  width: 300px;
}

.bar {
  fill: lightgrey;
  stroke: black;
}

.bar:hover {
  fill: steelblue;
}

.axis {
  font-family: Helvetica;
  font-size: 14px;
}

.axis--x path {
  display: none;
}

.axis--y path {
  display: none;
}

.grid line {
  stroke: lightgrey;
  stroke-opacity: 0.7;
}

.label {
  fill: black;
  font-family: Helvetica;
  font-size: 14px;
  text-anchor: middle;
}

.axis--map--caption {
  fill: black;
  font-family: Helvetica;
  font-size: 12px;
  text-anchor: start;
  font-weight: bold;
}

.zipcode {
  stroke: black;
	stroke-width: 1px;
	fill: none;
  opacity: 0.5;
}

.leaflet-edit-move {
  max-width: 16px;
  max-height: 16px;
  border-radius: 50%;
  background: #ff7800;
  border: 1px solid #000;
  opacity: 0.85;
}

.leaflet-edit-resize {
  max-width: 16px;
  max-height: 16px;
  border-radius: 50%;
  background: #0078ff;
  border: 1px solid #000;
  opacity: 0.85;
}

.infobox {
  text-align: left;
  line-height: 14px;
  font-size: 14px;
  color: #000000;
  width: 170px;
  height: 38px;

  margin-top: 0px;
  padding: 8px 8px;
  background: white;
  background: rgba(255,255,255,1);
  box-shadow: 0 0 15px rgba(0,0,0,0.2);
  border-radius: 5px;
}

/* html, body {
        position:relative;
      }
      html, body, #map {
        height: 100%;
        padding: 0;
        margin: 0;
      }
      .legend-selector {
        position:absolute;
        top: 20px; right: 20px;
        margin: 0; padding: 0;
        z-index: 100;
      }
      .legend-selector li {
        display:inline-block;
        margin: 0 0 0 10px; padding: 0;
        list-style:none;
      }
      .legend-selector li a {
        display:block;
        text-decoration:none;
        text-align:center;
        font: normal 13px "Helvetica",Arial;
        color: #858585;
        webkit-box-shadow: rgba(0, 0, 0, 0.2) 0 0 4px 2px;
        -moz-box-shadow: rgba(0, 0, 0, 0.2) 0 0 4px 2px;
        box-shadow: rgba(0, 0, 0, 0.2) 0 0 4px 2px;
        -webkit-border-radius: 4px;
        -moz-border-radius: 4px;
        -ms-border-radius: 4px;
        -o-border-radius: 4px;
        border-radius: 4px;
        border: 1px solid #999;
        background: #FFF;
        z-index: 5;
        padding: 10px;
      }
      .legend-selector li a.selected {
        background:#f1f1f1;
      } */

  </style>
</head>
<body>
  
  <script>
    // Data Viz Project 
/*******************************************************************
This is our code to create the front end user interface for data viz project.
*******************************************************************/


class App extends React.Component {

  constructor(props) {
    super(props);
    this.state = {
      city: 'Please Select your City',
      
      chain: true,
      strictly_coffee: true,
      bakeries: true,
      breakfast_and_brunch: true,
      diner: true,
      deli: true,
      icecream: true,
      juice: true,
      other: true,
      
      lowcost: true,
      medcost: true,
      hicost: true,
      hihicost: true,
      
      rating: 0,
    };
    
    this.handleSubmit = this.handleSubmit.bind(this);
    this.handleChange = this.handleChange.bind(this);
    this.handle_Reset = this.handle_Reset.bind(this);
    this.handleCheckboxChange = this.handleCheckboxChange.bind(this);
    
  }
    handleCheckboxChange(event){
        const target = event.target;
        const value = target.type === 'checkbox' ? target.checked : target.value;
        const name = target.name;
  
        this.setState({
            [name]: value
                                });
      }

     handleChange(event){
         this.setState({
        [event.target.name]: event.target.value});
      }

     handle_Reset() {
         //Need to code this
      }

handleSubmit(event) {
//   var spec = `/vis/${this.state.city}/
//                    ${this.state.chain}/
//                    ${this.state.bakeries}/
//                    ${this.state.boutique}/
//                    ${this.state.diner}/
//                    ${this.state.brunch}/
//                    ${this.state.icecream}/
//                    ${this.state.restaurants}/
//                    ${this.state.other}/
//                    ${this.state.lowcost}/
//                    ${this.state.medcost}/
//                    ${this.state.hicost}/
//                    ${this.state.rating}`;
     var spec = "https://raw.githubusercontent.com/andrewnell/Data_Visualization/master/DataViz2018_adn323/Project/test.json";
    vegaEmbed('#vis', spec, {actions:false});
    event.preventDefault();

  
    var city = this.state.city
    var chain = this.state.chain
    var strictly_coffee = this.state.strictly_coffee
    var bakeries = this.state.bakeries
    var diner = this.state.diner
    var deli = this.state.deli
    var breakfast_and_brunch = this.state.breakfast_and_brunch
    var icecream = this.state.icecream
    var juice = this.state.juice
    var other = this.state.other
    var lowcost = this.state.lowcost
    var medcost = this.state.medcost
    var hicost = this.state.hicost
    var hihicost = this.state.hihicost
    var rating = parseInt(this.state.rating)
    
    
    var coffeearr = []
    var coffeearr = convertArr(chain, 'chain', coffeearr)
    var coffeearr = convertArr(strictly_coffee, 'strictly_coffee', coffeearr)
    var coffeearr = convertArr(bakeries, 'bakeries', coffeearr)
    var coffeearr = convertArr(breakfast_and_brunch, 'breakfast_and_brunch', coffeearr)
    var coffeearr = convertArr(deli, 'deli', coffeearr)
    var coffeearr = convertArr(diner, 'diner', coffeearr)
    var coffeearr = convertArr(juice, 'juice_and_smoothie', coffeearr)
    var coffeearr = convertArr(icecream, 'icecream_and_froyo', coffeearr)
    var coffeearr = convertArr(other, 'other', coffeearr)
    
    var costarr = []
    var costarr = convertArr(lowcost, '$', costarr)
    var costarr = convertArr(medcost, '$$', costarr)
    var costarr = convertArr(hicost, '$$$', costarr)
    var costarr = convertArr(hihicost, '$$$$', costarr)
    
    var error = 'error'
   
    
//     d3.queue()
//   .defer(d3.json, ZIPCODE_URL)
//   .await(initVisualization(error, city, rating, coffeearr, costarr));
    console.log(city)
    initVisualization(error, city, rating, coffeearr, costarr)
//     setupSelectionHandlers(baseMap, coffeeSource, CITY, minR, typeARR, costARR)
    
    }
  



  render() {
    
   
    
    
    return (
    

      React.createElement("form", {onSubmit: this.handleSubmit}, 
                    
            React.createElement("label", null, 
                "           " + ' ' +  
                
                "Find your Coffee Shops",   
            
            React.createElement("br", null), React.createElement("br", null), 
            
            
                "City          ", 
                React.createElement("select", {
                    name: "city", 
                    value: this.state.city, 
                    onChange: this.handleChange}, 
                        React.createElement("option", {value: "NA"}, "Please Select your City"), 
                        React.createElement("option", {value: "Atlanta"}, "Atlanta"), 
                        React.createElement("option", {value: "Austin"}, "Austin"), 
                        React.createElement("option", {value: "Baltimore"}, "Baltimore"), 
                        React.createElement("option", {value: "Boston"}, "Boston"), 
                        React.createElement("option", {value: "Charlotte"}, "Charlotte"), 
                        React.createElement("option", {value: "Charlottesville"}, "Charlottesville"), 
                        React.createElement("option", {value: "Chicago"}, "Chicago"), 
                        React.createElement("option", {value: "Cleveland"}, "Cleveland"), 
                        React.createElement("option", {value: "Columbus"}, "Columbus"), 
                        React.createElement("option", {value: "Dallas"}, "Dallas"), 
                        React.createElement("option", {value: "Denver"}, "Denver"), 
                        React.createElement("option", {value: "Detroit"}, "Detroit"), 
                        React.createElement("option", {value: "Houston"}, "Houston"), 
                        React.createElement("option", {value: "Los Angeles"}, "Los Angeles"), 
                        React.createElement("option", {value: "Miami"}, "Miami"), 
                        React.createElement("option", {value: "New Orleans"}, "New Orleans"), 
                        React.createElement("option", {value: "New York"}, "New York"), 
                        React.createElement("option", {value: "Philadelphia"}, "Philadelphia"), 
                        React.createElement("option", {value: "Pittsburgh"}, "Pittsburgh"), 
                        React.createElement("option", {value: "Portland"}, "Portland"), 
                        React.createElement("option", {value: "Salt Lake City"}, "Salt Lake City"), 
                        React.createElement("option", {value: "San Francisco"}, "San Francisco"), 
                        React.createElement("option", {value: "Seattle"}, "Seattle"), 
                        React.createElement("option", {value: "Washington"}, "Washington")
                ), 
             
            React.createElement("br", null), 
          
          
                "Coffee Shop Type          ", React.createElement("br", null), "        " + ' ' +
                "Strictly Coffee ", React.createElement("input", {
                          type: "checkbox", 
                          name: "strictly_coffee", 
                          value: "strictly_coffee", 
                          checked: this.state.strictly_coffee, 
                          onChange: this.handleCheckboxChange}), "            " + ' ' +
                "Chain ", React.createElement("input", {
                          type: "checkbox", 
                          name: "chain", 
                          value: "chain", 
                          checked: this.state.chain, 
                          onChange: this.handleCheckboxChange}), "     " + ' ' +  
                "Bakeries ", React.createElement("input", {
                          type: "checkbox", 
                          name: "bakeries", 
                          value: "bakeries", 
                          checked: this.state.bakeries, 
                          onChange: this.handleCheckboxChange}), "    ", React.createElement("br", null), "   " + ' ' +
                "Breakfast and Brunch ", React.createElement("input", {
                          type: "checkbox", 
                          name: "breakfast_and_brunch", 
                          value: "breakfast_and_brunch", 
                          checked: this.state.breakfast_and_brunch, 
                          onChange: this.handleCheckboxChange}), "         " + ' ' +  
                "Diner ", React.createElement("input", {
                          type: "checkbox", 
                          name: "diner", 
                          value: "diner", 
                          checked: this.state.diner, 
                          onChange: this.handleCheckboxChange}), "      " + ' ' +  
                "Deli ", React.createElement("input", {
                          type: "checkbox", 
                          name: "deli", 
                          value: "deli", 
                          checked: this.state.deli, 
                          onChange: this.handleCheckboxChange}), "    ", React.createElement("br", null), "    " + ' ' +
                "Ice-cream and Froyo ", React.createElement("input", {
                          type: "checkbox", 
                          name: "icecream", 
                          value: "icecream", 
                          checked: this.state.icecream, 
                          onChange: this.handleCheckboxChange}), "   " + ' ' +  
                "Juice and Smoothie ", React.createElement("input", {
                          type: "checkbox", 
                          name: "juice", 
                          value: "juice", 
                          checked: this.state.juice, 
                          onChange: this.handleCheckboxChange}), "       " + ' ' +  
                "Other ", React.createElement("input", {
                          type: "checkbox", 
                          name: "other", 
                          value: "other", 
                          checked: this.state.other, 
                          onChange: this.handleCheckboxChange}), "   ",   
            React.createElement("br", null), 
            
          
              "Cost          " + ' ' +
                    "$   ", React.createElement("input", {
                          type: "checkbox", 
                          name: "lowcost", 
                          value: "lowcost", 
                          checked: this.state.lowcost, 
                          onChange: this.handleCheckboxChange}), "   " + ' ' + 
                    "$$  ", React.createElement("input", {
                          type: "checkbox", 
                          name: "medcost", 
                          value: "medcost", 
                          checked: this.state.medcost, 
                          onChange: this.handleCheckboxChange}), "  " + ' ' + 
                    "$$$ ", React.createElement("input", {
                          type: "checkbox", 
                          name: "hicost", 
                          value: "hicost", 
                          checked: this.state.hicost, 
                          onChange: this.handleCheckboxChange}), "  " + ' ' +
                    "$$$$ ", React.createElement("input", {
                          type: "checkbox", 
                          name: "hihicost", 
                          value: "hihicost", 
                          checked: this.state.hihicost, 
                          onChange: this.handleCheckboxChange}), 
            React.createElement("br", null), 
          
             
              "Minimum Rating  ", 
              React.createElement("select", {
                  name: "rating", 
                  value: this.state.rating, 
                  onChange: this.handleChange}, 
                      React.createElement("option", {value: "0"}, "0"), 
                      React.createElement("option", {value: "1"}, "1"), 
                      React.createElement("option", {value: "2"}, "2"), 
                      React.createElement("option", {value: "3"}, "3"), 
                      React.createElement("option", {value: "4"}, "4"), 
                      React.createElement("option", {value: "5"}, "5")
              )
              
        ), " ", React.createElement("br", null), "      ", 
        
         React.createElement("input", {type: "submit", value: "Update"}), "                                ", 
        
        
        

           
        
        React.createElement("button", {type: "button", onClick: this.handle_reset}, "Reset")
        
                    
                    
                )

    );
  }
 
}


ReactDOM.render(
  React.createElement("div", null, 
    React.createElement(App, null)
  ),
  document.getElementById('ui')
);




function convertArr(coffeetype, name, arr) {
   if (coffeetype === true) {
        var temp = [name];
        var arr = arr.concat(temp);
    } else {
        var temp = ['null'];
        var arr = arr.concat(temp);
    }
    
   return arr
}




// =====================================================================
// The usual definition for our data source URLs. We only need the zip
// code data in this lab. The cuisine data will be served through Carto
// Database back-end.
// =====================================================================
const ZIPCODE_URL = "https://raw.githubusercontent.com/hvo/datasets/master/nyc_zip.geojson";

// =====================================================================
// We are then asking D3 to read both of the files asynchronously with
// d3.queue(). Note that after this call, the data is NOT ready. They
// are only being put on the queue for the browser to fetch the data
// in the background (using the specified d3.json() function) since 
// loading files over the network always take time!
//
// Once the download completes, regardless being successful or not, D3
// will call the function that we provide in await() to handle the data
// or the error, respectively. In this case, it will call createPlot().
//
// NOTE: since we only need the zip code, there's only one defer() here.
// =====================================================================


// d3.queue()
//   .defer(d3.json, ZIPCODE_URL)
//   .await(initVisualization);



// =====================================================================
// This is where all the actions happen. The function signature is:
// - 1st argument     : error to indicate whether the queue has
//                      completed successfully or not
// - 2nd to the rest  : the result for each task on the queue, i.e.
//                      the data from the d3.json calls.
// If there are data-dependent setup in our webpage, we must put those
// setup in this callback function. We cannot do:
// data = d3.queue()...
// and then setup right after because the data would not be ready.
// 
// In this case, once we have the shape file, we will setup the chart,
// and a LeafLet map accordingly.
// =====================================================================
function initVisualization(error, CITY, minR, TypeARR, CostARR) {
  let svg       = d3.select("svg"),
      gChart    = svg.append("g"),

       
      // This is our LeafLet map with an editable circle selection.
      // See createBaseMap() for more details.
      baseMap   = createBaseMap(),
      
      // This holds the current selection of our application, the label
      // for the cuisine, and the counts per zip code.
      //selection = {cuisine: 'All', data: []};
  
      // This is to initiate a Carto's client to access the data and
      // visualizations on Carto. Note, for public data sets, we don't
      // need an API Key.
      client    = new carto.Client({
                    apiKey: 'NotNeeded',
                    username: 'paulinez',
                  });
  
  // First, populate our leaflet map
  //createMap(baseMap, zipcodes, selection);
  
  // And go fetch the restaurants data from Carto, and build the chart
  //createChartFromCarto(client, gChart, baseMap[1], selection);

  // Then, we add a layer from Carto showing the subway entrances. We
  // also need the data SQL source so that we can alter the query when
  // our circle selection is changed.
  
//   var ARR = ["chain", "strictly_coffee", "bakeries", "breakfast_and_brunch", "deli", "diner", "juice_and_smoothie", "icecream_and_froyo", "other"]
  
//   var ARR2 = ["$", "$$", "$$$", "$$$$"]
  
  let coffeeSource = createCartoLayer(client, baseMap, CITY, minR, TypeARR, CostARR);
  
  
  // Finally, we monitor the selection change events so that we know when
  // to update our SQL.
  setupSelectionHandlers(baseMap, coffeeSource, CITY, minR, TypeARR, CostARR);
  
  return baseMap, coffeeSource, client;
}

// =====================================================================
// Instead of creating the bar chart based on the cuisine data loaded
// locally on the user machine, we will fetch the data from the Carto's
// database back-end. Inputs are the following:
//   - client    : an authorized session with Carto that we have created
//                 in initVisualization() prior to this function call.
//   - gChart    : an SVG group for holding the bar chart.
//   - gMap      : likewise, this is an SVG group for holding the map,
//                 which should have been created by createMap().
//   - selection : the global selection with the data and cuisine name.
// =====================================================================
// function createChartFromCarto(client, gChart, gMap, selection) {
  
//   // Define our data source as a SQL query: we get everything from the
//   // nyc_restaurant_grades table of user 'htv210'.
//   const resData = new carto.source.SQL(`
//     SELECT *
//       FROM htv210.nyc_restaurant_grades
//   `);

//   // This is the call-back function, which will be called whenever our
//   // queried data is changed. Since we only want to call it intially
//   // to create our chart, we also remove its signal in the call so 
//   // that all change events will not trigger this.
// //   var initBarChart = function (newData) {
// //     // The data is of the Category type (see the query below), so we
// //     // have to retrieve our interested info inside the .categories.
// //     let byCuisine = newData.categories.map(d => [d.name, d.value]);
    
// //     // With that, we go through the typical createChart() as seen in
// //     // the previous labs
// //     createChart(gChart, byCuisine, resData, selection);
    
// //     // This is to turn off the signal, since we only want to call once
// //     totalView.off('dataChanged', initBarChart);
// //   }

//   // Data in Carto are typically retrieved through View, similar to 
//   // views in database system. A view needs to have a "query", and
//   // and a data source. Whenever the query or the data changed, the
//   // viewed data will also be updated.
//   // Here, we create a view on top of the restaurant data, expected
//   // the results of cateogry types through the operation "COUNT",
//   // for counting the number of restaurant per cuisine.
//   // By default, Carto only returns 6 results, thus, we need to set
//   // the limit to a large number, e.g. 1000, to retrieve everything.
//   const totalView = new carto.dataview.Category(
//     resData,  'cuisine', {
//       operation: carto.operation.COUNT,
//       limit: 1000,
//   }).on('dataChanged', initBarChart);

//   // The view above is good for retrieving the restaurant counts
//   // to build our bar chart. In addition, we also need the counts
//   // per zip code to build our map as well. This is the view for it.
//   //
//   // Note: we defined the call-back function in-place below (instead
//   // of putting that into another variable like initBarChart) since
//   // we do not need to store the function for turn off the signals.
//   // The initBarChart declaration above is needed for that purpose.
//   const zipView = new carto.dataview.Category(
//     resData,  'zipcode', {
//       operation: carto.operation.COUNT,
//       limit: 1000,
//   }).on('dataChanged', newData => {
//     // In this call-back, we also store the data into our selection
//     // before update the map with that contents.
//     selection.data = newData.categories.map(d => [d.name, d.value]);
//     updateMap(gMap, selection);
//   });
  
//   // After we create the views, we tell Carto's client to keep track
//   // of them (in order for them to reflect the data dynamically).
//   client.addDataview(totalView);
//   client.addDataview(zipView);
// }

// =====================================================================
// This is the same createChart() function as we have seen in previous
// labs. We create the chart inside the input group 'g', keeping track of
// the mapping group 'gMap', and use the data stored in 'byCuisine'.
//
// The only major change is in the update. Since we're connecting to a
// a database back-end, we only update the maps when the user clicks.
// Otherwise, it would be a strain on our data back-end.
// =====================================================================
// function createChart(g, byCuisine, sqlSource, selection) {
//   let data     = byCuisine.slice(0, 25),
//       maxValue = d3.max(data, d => d[1]),
//       x        = d3.scaleLinear()
//                    .domain([0, maxValue])
//                    .rangeRound([0, 300]),
//       yb       = d3.scaleBand()
//                    .domain(data.map(d => d[0]))
//                    .rangeRound([50, 600]),
//       cHeight  = yb(data.slice(-1)[0][0])-yb.bandwidth();
 
//   g.append("g")
//     .attr("class", "axis axis--x")
//     .attr("transform", "translate(165,50)")
//     .call(d3.axisTop(x).ticks(5));

//   g.append("g")
//     .attr("class", "axis axis--y")
//     .attr("transform", "translate(160,0)")
//     .call(d3.axisLeft(yb));  
  
//   g.append("g")
//     .attr("class", "grid axis--x")
//     .attr("transform", "translate(165,50)")   
//     .call(d3.axisTop(x).ticks(5).tickSize(-cHeight).tickFormat(""));

//   g.append("g")
//     .attr("class", "axis axis--x")
//     .attr("transform", `translate(165,${50+cHeight})`)
//     .call(d3.axisBottom(x).ticks(5))
//     .append("text")
//       .attr("class", "label")
//       .attr("x", 150)
//       .attr("y", 40)
//       .text("Number of Restaurants");

//   g.selectAll(".bar")
//     .data(data)
//     .enter().append("rect")
//       .attr("class", "bar")
//       .attr("x", 165)
//       .attr("y", function(d,i) { return yb(d[0]); })
//       .attr("width", function(d,i) { return x(d[1]); })
//       .attr("height", yb.bandwidth()-2)
//       .on("mouseover", function(d, i) {
//         d3.select(this)
//           .transition().duration(300)
//           .attr("x", 165-10)
//           .attr("y", yb(d[0])-2)
//           .attr("width", x(d[1])+20)
//           .attr("height", yb.bandwidth()+2);
//       })
//       .on('click', function (d,i) {
//         // *** UPDATED ***
//         // We change our query based on the user input, aka. 
//         // the selected cusine name.
//         var query = `
//           SELECT *
//             FROM htv210.nyc_restaurant_grades
//            WHERE cuisine='${d[0]}'
//         `;
    
//         // We update the query the selection accordingly
//         sqlSource.setQuery(query);
//         selection.cuisine = d[0];
//       })
//       .on("mouseout", function(d) { 
//         d3.select(this)
//           .transition().duration(300)
//           .attr("x", 165)
//           .attr("y", yb(d[0]))
//           .attr("width", x(d[1]))
//           .attr("height", yb.bandwidth()-2);
//       });  
// }

// =====================================================================
// This is for us to show a static (canned) visualization using the data
// on Carto. Here, we pretty much "copy and paste" the SQL and CSS from
// Carto's Builder over.
// =====================================================================

// IF strictly_coffee = True ARR.append(stricky_coffe) else, ARR.append(Null)
// var ARR = [chain, null, ]

function createCartoLayer(client, baseMap, CITY, minR, typeARR, costARR) {
  
  
  // We specify the data source for our visualization, which is the
  // subway entrances. We can use the Data's SQL part from the Builder.
  let coffeeSource = new carto.source.SQL(`
    SELECT * FROM paulinez.allcity
    WHERE city = '${CITY}'
    AND rating > ${minR}
    AND (primary_ca = '${typeARR[0]}' OR
         primary_ca = '${typeARR[1]}' OR
         primary_ca = '${typeARR[2]}' OR
         primary_ca = '${typeARR[3]}' OR
         primary_ca = '${typeARR[4]}' OR
         primary_ca = '${typeARR[5]}' OR
         primary_ca = '${typeARR[6]}' OR
         primary_ca = '${typeARR[7]}' OR
         primary_ca = '${typeARR[8]}')
    AND (price = '${costARR[0]}' OR
         price = '${costARR[1]}' OR
         price = '${costARR[2]}' OR
         price = '${costARR[3]}')
    
    
  `);

  // We also need to style our data, through CartoCSS, which is also
  // copied over from the Builder
  let coffeeStyle= new carto.style.CartoCSS(`
#layer {
  marker-width: ramp([rating], range(5, 15), quantiles(4));
  marker-fill: #d11e2d;
  marker-fill-opacity: 0.9;
  marker-allow-overlap: true;
  marker-line-width: 1;
  marker-line-color: #FFFFFF;
  marker-line-opacity: 1;
}
  `);
  
  

  
  // After that, we just tell Carto to create a layer with both the style
  // and the data. The good thing is Carto supports LeafLet!
  let coffeeLayer = new carto.layer.Layer(coffeeSource, coffeeStyle);
  client.addLayer(coffeeLayer);
  client.getLeafletLayer().addTo(baseMap[2]);
  return coffeeSource;
}



// =====================================================================
// This is similar to what we have in the previous labs, except that
// instead of passing the data, we pass the current selection with both
// the cuisine name and the data.
// =====================================================================
// function createMap(baseMap, zipcodes, selection) {
  
//   function projectPoint(x, y) {
//     let point = dMap.latLngToLayerPoint(new L.LatLng(y, x));
//     this.stream.point(point.x, point.y);
//   }

//   let projection = d3.geoTransform({point: projectPoint}),
//       path       = d3.geoPath().projection(projection),
//       svg        = baseMap[0],
//       g          = baseMap[1],
//       dMap       = baseMap[2];
  
//   // The legend control is an overlay layer, i.e. it doesn't move with
//   // the user interactions. We create this control through LeafLet, and
//   // add it to our map.
//   let legendControl   = L.control({position: 'topleft'});
  
//   // On adding the legend to LeafLet, we will setup a <div> to show
//   // the selection information.
//   legendControl.onAdd = addLegendToMap;
//   legendControl.addTo(dMap);
  
//   // The tricky part now is we need to sync up the projection between
//   // LeafLet and D3's shapes. We need to write a special handler for
//   // that, naming reproject(). This will get called whenever the user
//   // zoon in or out with the map.
//   dMap.on("zoomend", reproject);
//   reproject();
  
//   // This function gets called when we first add the legend box. We
//   // perform some styling to make it looks nice here.
//   function addLegendToMap(map) {
//     let div    = L.DomUtil.create('div', 'legendbox'),
//         ndiv   = d3.select(div)
//                    .style("left", "50px")
//                    .style("top", "-75px"),
//         lsvg   = ndiv.append("svg"),
//         legend = lsvg.append("g")
//                    .attr("class", "legend")
//                    .attr("transform", "translate(0, 20)");
//     legend.append("text")
//       .attr("class", "axis--map--caption")
//       .attr("y", -6);
//     return div;
//   };

//   // This function realign the shapes to the zoom level of LeafLef map.
//   // The key action here is to get the bounds of the geometries in this
//   // zoom, reproject the path, and update all geometries with the new
//   // reprojected information.
//   function reproject() {
//     // First we compute the bounds, and shift our SVG accordingly
// 		bounds = path.bounds(zipcodes);
//     let topLeft     = bounds[0],
//         bottomRight = bounds[1];
//     svg.attr("width", bottomRight[0] - topLeft[0])
//       .attr("height", bottomRight[1] - topLeft[1])
//       .style("left", topLeft[0] + "px")
//       .style("top", topLeft[1] + "px");

//     // Then also transform our map group
//     g.attr("transform", `translate(${-topLeft[0]}, ${-topLeft[1]})`);

//     // And update the actual D3 visual elements
//     let zipShapes = g.selectAll(".zipcode")
//       .data(zipcodes.features); // we rejoin the data
//     zipShapes
//       .enter().append("path")
//         .attr("class", "zipcode")
//       .merge(zipShapes) // and perform updates on both match and unmatches
//         .attr("d", path);

//     // Redraw the map
//     updateMap(g, selection);
//   }
// }

// function updateMap(g, selection) {
//   let data     = selection.data,
//       maxCount = d3.max(data, d => d[1]),
//       steps    = 5,
//       color    = d3.scaleThreshold()
//                    .domain(d3.range(0, maxCount, maxCount/steps))
//                    .range(d3.schemeBlues[steps])
//       zipcodes = g.selectAll(".zipcode")
//                    .data(data, d => (d[0]?d[0]:d.properties.zipcode)),
//       x        = d3.scaleLinear()
//                    .domain([0, maxCount])
//                    .rangeRound([50, 300]),
//       legend   = d3.select(".legend");

//   zipcodes
//     .transition().duration(300)
//     .style("fill", d => color(d[1]));
  
//   zipcodes.exit()
//     .transition().duration(300)
//     .style("fill", "none");
  
//   let boxes = legend.selectAll("rect")
//     .data(color.range().map(function(d) {
//         d = color.invertExtent(d);
//         return [(d[0]!==null?d[0]:x.domain()[0]),
//                 (d[1]!==null?d[1]:x.domain()[1])];
//       }));

//   boxes
//     .enter().append("rect")
//     .merge(boxes)
//       .attr("height", 6)
//       .attr("x", d => x(d[0]))
//       .attr("width", d => (x(d[1]) - x(d[0])))
//       .attr("fill", d => 'SteelBlue');

//   legend.call(d3.axisBottom(x)
//       .ticks(steps, "s")
//       .tickSize(10,0)
//       .tickValues(color.domain()))
//     .select(".domain")
//       .remove();
  
//   legend.select(".axis--map--caption")
//     .attr("x", x.range()[0])
//     .text(`Number of ${selection.cuisine} Restaurants`);
// }

var CityCenter = {'Atlanta':[33.755, -84.3828], 'Austin':[30.2675,-97.7429], 'Baltimore':[39.2897,-76.6122],
              'Boston':[42.3485,-71.0671], 'Cambridge':[42.3743,-71.1220], 'Newton':[42.3303,-71.1922],
              'Charlotte':[35.2270,-80.8420], 'Charlottesville':[38.03066,-78.4790], 'Chicago':[41.8779,-87.629], 
              'Cleveland':[41.5015,-81.695], 'Columbus':[39.96379,-83.0003],'Dallas':[32.7799,-96.7978],
              'Denver':[39.73659,-104.98446], 'Detroit':[42.34605,-83.0553], 'Houston':[29.76012,-95.36560],
              'Los Angeles':[34.0510,-118.254], 'Miami':[25.7738,-80.1942],'New Orleans':[29.9483,-90.0722],
              'New York':[40.7, -73.975], 'Philadelphia':[39.94852,-75.1621], 'Pittsburgh':[40.44167,-79.99620],
              'Portland':[45.5234,-122.66305],'Salt Lake City':[40.7599,-111.884], 'San Francisco':[37.7757,-122.4225], 
              'Seattle':[47.6098,-122.3277]}

function createBaseMap() {
  let center = CityCenter['Atlanta']
//      let center    = [40.7, -73.975],  //New York 
//      let center = [33.755, -84.3828] //Atlanta
//      let center = [30.2675,-97.7429] //Austin
//      let center = [39.2897,-76.6122] //Baltimore
//      let center = [42.3485,-71.0671] //Boston
//      let center = [42.3743,-71.1220] //Cambridge
//      let center = [42.3303,-71.1922] //Newton
//      let center = [35.2270,-80.8420] //Charlotte
//      let center = [38.03066,-78.4790] //Charlottesville
//      let center = [41.8779,-87.629] //Chicago
//      let center = [41.5015,-81.695] //Cleveland
//      let center = [39.96379,-83.0003] //Columbus
//      let center = [32.7799,-96.7978] //Dallas
//      let center = [39.73659,-104.98446] //Denver
//      let center = [42.34605,-83.0553] //Detroit
//      let center = [29.76012,-95.36560] //Houston
//      let center = [34.0510,-118.254] //LosAngeles
//      let center = [25.7738,-80.1942] //Miami
//      let center = [29.9483,-90.0722] //NewOrleans
//      let center = [39.94852,-75.1621] //Philadelphia
//      let center = [40.44167,-79.99620] //Pittsburgh
//      let center = [45.5234,-122.66305] //Portland
//      let center = [40.7599,-111.884] //SaltLakeCity
//      let center = [37.7757,-122.4225] //San Francisco
//      let center = [47.6098,-122.3277] //Seattle

   
      baseLight = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png',
                              { maxZoom: 18, }),
      baseDark  = L.tileLayer('https://cartodb-basemaps-{s}.global.ssl.fastly.net/dark_all/{z}/{x}/{y}.png',
                              { maxZoom: 18, }),
      circle    = L.circle(center, 1000, options={editable: true}),
      dMap      = L.map('map', {
                    center: center,
                    zoom: 13,
                    layers: [baseLight]
                  }),
      svg       = d3.select(dMap.getPanes().overlayPane).append("svg"),
			g         = svg.append("g").attr("class", "leaflet-zoom-hide");
                                 //.attr("transform", "translate(0,70)");
                            
  
  L.control.layers({
                    "Light": baseLight,
                    "Dark" : baseDark,
                   }, 
                   {
                    "Selection": circle,
                   }).addTo(dMap);
  
  let infoBox = L.control({position: 'bottomleft'});
//   let test = L.control({position: 'bottomright'});
  infoBox.onAdd = function (map) {var div = L.DomUtil.create('div', 'infobox'); return div;}
//   test.onAdd = function (map){var div1 = L.DomUtil.create('div1', 'test');
// return div1;}
  infoBox.addTo(dMap);
//   test.addTo(dMap);

  return [svg, g, dMap, circle];
}



function setupSelectionHandlers(baseMap, coffeeSource, CITY, minR, typeARR, costARR) {
  let dMap    = baseMap[2],
      circle  = baseMap[3],
      infoBox = d3.select(".infobox.leaflet-control");

  var CityCenter = {'Please Select your City':[[39.003711, -101.867199],4],
    'Atlanta':[[33.755, -84.3828],12], 
                    'Austin':[[30.2675,-97.7429],12], 
                    'Baltimore':[[39.2897,-76.6122],13],
                    'Boston':[[42.3485,-71.0671],12], 
                    'Cambridge':[42.3743,-71.1220], 
                    'Newton':[42.3303,-71.1922],
                    'Charlotte':[[35.2270,-80.8420],11], 
                    'Charlottesville':[[38.03066,-78.4790],13], 
                    'Chicago':[[41.8779,-87.629],11], 
                    'Cleveland':[[41.5015,-81.695],12], 
                    'Columbus':[[39.96379,-83.0003],11],
                    'Dallas':[[32.7799,-96.7978],11],
                    'Denver':[[39.73659,-104.98446],12], 
                    'Detroit':[[42.34605,-83.0553],11], 
                    'Houston':[[29.76012,-95.36560],11],
                    'Los Angeles':[[34.0510,-118.254],11],
                    'Miami':[[25.7738,-80.1942],12],
                    'New Orleans':[[29.9483,-90.0722],12],
                    'New York':[[40.7, -73.975],11], 
                    'Philadelphia':[[39.94852,-75.1621],12], 
                    'Pittsburgh':[[40.44167,-79.99620],12],
                    'Portland':[[45.5234,-122.66305],12],
                    'Salt Lake City':[[40.7599,-111.884],12], 
                    'San Francisco':[[37.7757,-122.4225],11],
                    'Seattle':[[47.6098,-122.3277],11],
                    'Washington':[[38.8955,-77.02769],12]}
  
  
  dMap.on(L.Draw.Event.EDITMOVE, updateQueryStatus);
  dMap.on(L.Draw.Event.EDITRESIZE, updateQueryStatus);
  dMap.setView(CityCenter[CITY][0], CityCenter[CITY][1])
  dMap.on('mouseup', updateQuery);

  let circleUpdated = true;
  updateQueryStatus(null);

  function updateQueryStatus(e) {
    circleUpdated = true;
    updateCaption();
  }

  function updateQuery(e) {
    if (circleUpdated) {
      circleUpdated = false;
      let radius = circle.getRadius(),
          lat    = circle.getLatLng().lat.toFixed(4),
          lng    = circle.getLatLng().lng.toFixed(4),
          query  = `SELECT * FROM paulinez.allcity
                    WHERE city = '${CITY}'
                    AND rating > ${minR}
                    AND (primary_ca = '${typeARR[0]}' OR
                         primary_ca = '${typeARR[1]}' OR
                         primary_ca = '${typeARR[2]}' OR
                         primary_ca = '${typeARR[3]}' OR
                         primary_ca = '${typeARR[4]}' OR
                         primary_ca = '${typeARR[5]}' OR
                         primary_ca = '${typeARR[6]}' OR
                         primary_ca = '${typeARR[7]}' OR
                         primary_ca = '${typeARR[8]}')
                    AND (price = '${costARR[0]}' OR
                         price = '${costARR[1]}' OR
                         price = '${costARR[2]}' OR
                         price = '${costARR[3]}')
                       AND ST_DWithin(the_geom::geography,
                                      CDB_LatLng(${lat},${lng})::geography,
                                      ${radius})
          `;
      coffeeSource.setQuery(query);
    }
  }

  function updateCaption() {
    let radius  = L.GeometryUtil.readableDistance(circle.getRadius(), true),
        lat     = circle.getLatLng().lat.toFixed(4),
        lng     = circle.getLatLng().lng.toFixed(4),
        caption = `<table style='width:100%'>
                   <tr><th>Coords</th><td>${lat},${lng}</td></tr>
                   <tr><th>Radius</th><td>${radius}</td></tr>
                   </table>`;
    infoBox.html(caption);
  }    
}



  </script> 
  <ul class="legend-selector"> </ul>
  <div id="ui"></div>
  <div id="vis"></div>
  <div id="maps">
    <div id="chart">
      <svg width="550" height="650">
      </svg>
    </div>
    <div id="map">
      <div class="legends"></div>
    </div>
    </div>
  </div>
</body>
</html>
